#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
CLC bio assembly file CAS, and the tabular format generated by `assembly_table
-n -s -p`
"""

import os
import os.path as op
import sys
import logging

from itertools import groupby
from optparse import OptionParser

from Bio import SeqIO

from jcvi.formats.base import LineFile
from jcvi.formats.blast import report_pairs
from jcvi.apps.base import ActionDispatcher, sh, set_grid, debug
debug()


class CasTabLine (LineFile):
    """
    The table generate by command `assembly_table -n -s -p`
    from clcbio assembly cell
    """
    def __init__(self, line):
        args = line.split()
        self.readnum = args[0]  # usually integer or `-`
        self.readname = args[1]
        self.readlen = int(args[-10])
        # 0-based indexing
        self.readstart = int(args[-9])
        if self.readstart >= 0:
            self.readstart += 1

        self.readstop = int(args[-8])
        self.refnum = int(args[-7])

        self.refstart = int(args[-6])
        if self.refstart >= 0:
            self.refstart += 1

        self.refstop = int(args[-5])

        self.is_reversed = (int(args[-4]) == 1)
        self.strand = '-' if self.is_reversed else '+'

        self.nummatches = int(args[-3])
        self.is_paired = (int(args[-2]) == 1)
        self.score = int(args[-1])

    @property
    def bedline(self):
        return "\t".join(str(x) for x in (self.refnum,
            self.refstart - 1, self.refstop, self.readname,
            self.score, self.strand))


def main():

    actions = (
        ('txt', "convert CAS file to tabular output using assembly_table"),
        ('split', 'split CAS file into smaller CAS using sub_assembly'),
        ('bed', 'convert cas tabular output to bed format'),
        ('pairs', 'print paired-end reads of cas tabular output'),
        ('fastpairs', 'print pair distance and orientation, assuming paired '\
            'reads next to one another'),
            )
    p = ActionDispatcher(actions)
    p.dispatch(globals())


def fastpairs(args):
    """
    %prog fastpairs castabfile

    Assuming paired reads are adjacent in the castabfile. Print pair distance
    and orientations.
    """
    from jcvi.utils.range import range_distance

    p = OptionParser(fastpairs.__doc__)

    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())

    castabfile, = args
    fp = open(castabfile)
    arow = fp.readline()
    orientationlabels = {"++": "normal", "+-": "innie", "-+": "outie", "--": "antinormal"}
    while arow:
        brow = fp.readline()
        a, b = CasTabLine(arow), CasTabLine(brow)
        asubject, astart, astop = a.refnum, a.refstart, a.refstop
        bsubject, bstart, bstop = b.refnum, b.refstart, b.refstop
        if -1 not in (astart, bstart):
            aquery, bquery = a.readname, b.readname
            astrand, bstrand = a.strand, b.strand
            dist, orientation = range_distance(\
                (asubject, astart, astop, astrand),
                (bsubject, bstart, bstop, bstrand)
                    )
            orientation = orientationlabels[orientation]
            if dist != -1:
                print "\t".join(str(x) for x in (aquery, bquery, dist, orientation))
        arow = fp.readline()


def txt(args):
    """
    %prog txt casfile

    convert binary CAS file to tabular output using CLC assembly_table
    """
    p = OptionParser(txt.__doc__)
    set_grid(p)

    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())

    grid = opts.grid

    casfile, = args
    txtfile = casfile.replace(".cas", ".txt")
    assert op.exists(casfile)

    if op.exists(txtfile):
        os.remove(txtfile)

    cmd = "assembly_table -n -s -p {0}".format(casfile)
    sh(cmd, grid=grid, outfile=txtfile)

    return txtfile


def split(args):
    """
    %prog split casfile 1 10

    split the binary casfile by using CLCbio `sub_assembly` program, the two
    numbers are starting and ending index for the `reference`; useful to split
    one big assembly per contig
    """
    p = OptionParser(split.__doc__)
    set_grid(p)

    opts, args = p.parse_args(args)

    if len(args) != 3:
        sys.exit(p.print_help())

    casfile, start, end = args
    start = int(start)
    end = int(end)

    split_cmd = "sub_assembly -a {casfile} -o sa.{i}.cas -s {i} " + \
        "-e sa.{i}.pairs.fasta -f sa.{i}.fragments.fasta -g sa.{i}.ref.fasta"

    for i in range(start, end + 1):
        cmd = split_cmd.format(casfile=casfile, i=i)
        sh(cmd, grid=opts.grid)


def bed(args):
    """
    %prog bed casfile fastafile

    convert the CAS or CASTAB format into bed format
    """

    p = OptionParser(bed.__doc__)
    opts, args = p.parse_args(args)

    if len(args) != 2:
        sys.exit(p.print_help())

    casfile, fastafile = args
    if casfile.endswith(".cas"):
        castabfile = casfile.replace(".cas", ".txt")
        if not op.exists(castabfile):
            castabfile = txt([casfile])
        else:
            logging.debug("File `{0}` found.".format(castabfile))
    else:
        castabfile = casfile

    refnames = [rec.id for rec in SeqIO.parse(fastafile, "fasta")]
    fp = open(castabfile)
    bedfile = castabfile.rsplit(".", 1)[0] + ".bed"
    fw = open(bedfile, "w")
    for row in fp:
        b = CasTabLine(row)
        if b.readstart == -1:
            continue
        b.refnum = refnames[b.refnum]
        print >> fw, b.bedline

    logging.debug("File written to `{0}`.".format(bedfile))


def pairs(args):
    """
    %prog pairs castabfile

    report summary of the cas tabular results, how many paired ends mapped, avg
    distance between paired ends, etc
    """
    p = OptionParser(pairs.__doc__)
    p.add_option("--cutoff", dest="cutoff", default=0, type="int",
            help="distance to call valid links between PE [default: %default]")
    p.add_option("--pairs", dest="pairsfile",
            default=False, action="store_true",
            help="write valid pairs to pairsfile")
    p.add_option("-n", dest="nrows",
            default=100000, type="int",
            help="only use the first n lines [default: %default]")
    p.add_option("-r", dest="rclip", default=1, type="int",
            help="pair ID is derived from rstrip N chars [default: %default]")
    p.add_option("--inserts", dest="insertsfile", default=True,
            help="write insert sizes to insertsfile and plot distribution " + \
            "to insertsfile.pdf")

    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())

    rclip = opts.rclip
    cutoff = opts.cutoff
    if cutoff:
        cutoff = int(cutoff)
    castabfile, = args

    basename = castabfile.split(".")[0]
    pairsfile = ".".join((basename, "pairs")) if opts.pairsfile else None
    insertsfile = ".".join((basename, "inserts")) if opts.insertsfile else None

    fp = open(castabfile)
    data = [CasTabLine(row) for i, row in enumerate(fp) if i < opts.nrows]
    data.sort(key=lambda x: x.readname)

    report_pairs(data, cutoff, dialect="castab", pairsfile=pairsfile,
           insertsfile=insertsfile, rclip=rclip)


if __name__ == '__main__':
    main()
