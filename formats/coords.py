#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
parses JCVI software NUCMER (http://mummer.sourceforge.net/manual/)
output - mostly as *.coords file.
"""

import sys
import itertools
import logging

from itertools import groupby
from optparse import OptionParser

from jcvi.formats.base import LineFile
from jcvi.apps.base import ActionDispatcher, debug
debug()

Overlap_types = ("none", "a ~ b", "b ~ a", "a in b", "b in a")

class CoordsLine (object):

    """
    The coords line looks like (in one line):
        2953     4450  |      525     2023  |     1498     1499  |    98.07  |
        8046     2023  |    18.62    74.10  | gi|270341414|gb|AC182814.30|_2    contig_100476

    the coords file needs to be generated by `show-coords -rcl`
    """
    def __init__(self, row):
        
        row = row.replace(" | ", "")
        atoms = row.split()
        assert len(atoms) in (13, 17), "expecting 13 or 17 columns"
        
        self.start1 = int(atoms[0])
        self.end1 = int(atoms[1])
        
        self.start2 = int(atoms[2])
        self.end2 = int(atoms[3])

        if self.start2 > self.end2:
            self.start2, self.end2 = self.end2, self.start2
            self.orientation = '-'
        else:
            self.orientation = '+'
        
        self.len1 = int(atoms[4])
        self.len2 = int(atoms[5])

        self.identity = float(atoms[6])

        self.reflen = int(atoms[7])
        self.querylen = int(atoms[8])

        self.refcov = float(atoms[9]) / 100.
        self.querycov = float(atoms[10]) / 100.
        
        self.ref = atoms[11]
        self.query = atoms[12]

        # this is taken from CoGeBlast:
        # the coverage of the hit muliplied by percent seq identity
        # range from 0-100
        self.quality = self.identity * self.querycov
        self.score = self.identity * self.len1

    def __str__(self):
        slots = "ref start1 end1 reflen " +\
                "query start2 end2 querylen orientation"
        return "\t".join(str(x) for x in \
                [getattr(self, attr) for attr in slots.split()])

    @property
    def bedline(self):
        # bed formatted line
        score = int(self.quality * 10)
        return '\t'.join((self.ref, str(self.start1-1), str(self.end1), 
                self.query, str(score), self.orientation))

    @property
    def overlap(self, max_hang=100):
        """
        Determine the type of overlap given the query, ref alignment coordinates
        Consider the following alignment between sequence a and b:

        aLhang \              / aRhang
                \------------/
                /------------\ 
        bLhang /              \ bRhang

        Terminal overlap: a before b, b before a
        Contain overlap: a in b, b in a
        """
        aL, aR = 1, self.reflen
        bL, bR = 1, self.querylen
        aLhang, aRhang = self.start1 - aL, aR - self.end1
        bLhang, bRhang = self.start2 - bL, bR - self.end2
        #print aLhang, aRhang, bLhang, bRhang
        
        s1 = aLhang + bRhang
        s2 = aRhang + bLhang
        s3 = aLhang + aRhang
        s4 = bLhang + bRhang
        
        # Dovetail (terminal) overlap
        if s1 < max_hang: type = 2    # b ~ a
        elif s2 < max_hang: type = 1  # a ~ b
        # Containment overlap
        elif s3 < max_hang: type = 3  # a in b
        elif s4 < max_hang: type = 4  # b in a
        else: type = 0
        
        return type


class Coords (LineFile):
    
    """
    when parsing the .coords file, first skip first 5 lines
    [S1] [E1] | [S2] [E2] | [LEN 1] [LEN 2] | [% IDY] | [TAGS]

    then each row would be composed as this
    """
    def __init__(self, filename, sorted=False):
        super(Coords, self).__init__(filename)

        fp = open(filename)
        self.cmd = fp.next()
        
        for row in fp:
            try:
                self.append(CoordsLine(row))
            except AssertionError, e:
                pass

        if sorted:
            self.ref_sort()

    def ref_sort(self):
        # sort by reference positions
        self.sort(key=lambda x: (x.ref, x.start1))

    def quality_sort(self):
        # sort descending with score = identity * coverage
        self.sort(key=lambda x: (x.query, -x.quality))

    @property
    def hits(self):
        """
        returns a dict with query => blastline
        """
        self.quality_sort()

        hits = dict((query, list(blines)) for (query, blines) in \
                itertools.groupby(self, lambda x: x.query))

        self.ref_sort()

        return hits

    @property
    def best_hits(self):
        """
        returns a dict with query => best mapped position 
        """
        self.quality_sort()

        best_hits = dict((query, blines.next()) for (query, blines) in \
                itertools.groupby(self, lambda x: x.query))
        
        self.ref_sort()

        return best_hits


def get_stats(coordsfile):
    
    from jcvi.utils.range import range_union

    logging.debug("report stats on `%s`" % coordsfile)
    fp = open(coordsfile)
    ref_ivs = []
    qry_ivs = []
    identicals = 0
    alignlen = 0

    for row in fp:
        try:
            c = CoordsLine(row)
        except AssertionError:
            continue

        qstart, qstop = c.start2, c.end2
        if qstart > qstop: qstart, qstop = qstop, qstart
        qry_ivs.append((c.query, qstart, qstop))

        sstart, sstop = c.start1, c.end1
        if sstart > sstop: sstart, sstop = sstop, sstart
        ref_ivs.append((c.ref, sstart, sstop))

        alen = sstop - sstart
        alignlen += alen
        identicals += c.identity / 100. * alen 

    qrycovered = range_union(qry_ivs)
    refcovered = range_union(ref_ivs)
    id_pct = identicals * 100. / alignlen 

    return qrycovered, refcovered, id_pct 


def main():
    
    actions = (
        ('summary', 'provide summary on id% and cov%'),
        ('filter', 'filter based on id% and cov%, write a new coords file'),
        ('bed', 'convert to bed format'),
        ('agp', 'link contigs based on the coordsfile'),
        ('coverage', 'report the coverage per query record'),
            )
    p = ActionDispatcher(actions)
    p.dispatch(globals())


def coverage(args):
    """
    %prog coverage coordsfile

    Report the coverage per query record, useful to see which query matches
    reference.  The coords file MUST be filtered with supermap::
    
    jcvi.algorithms.supermap -f query 
    """
    p = OptionParser(coverage.__doc__)
    p.add_option("-c", dest="cutoff", default=0.5, type="float",
            help="only report the query IDs with coverage larger than [default: %default]")
    
    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())
    
    coordsfile, = args
    fp = open(coordsfile)
    
    coords = []
    for row in fp:
        try:
            c = CoordsLine(row)
        except AssertionError:
            continue
        coords.append(c)

    coords.sort(key=lambda x: x.query)

    coverages = []
    for query, lines in groupby(coords, key=lambda x: x.query):
        cumulative_cutoff = sum(x.querycov for x in lines)
        coverages.append((query, cumulative_cutoff))

    coverages.sort(key=lambda x: (-x[1], x[0]))
    for query, cumulative_cutoff in coverages:
        if cumulative_cutoff < opts.cutoff: break 
        print "{0}\t{1:.2f}".format(query, cumulative_cutoff)


def agp(args):
    """
    %prog agp coordsfile

    coordsfile has to be supermapped (or delta-filtered) to get non-overlapping
    ranges for the reference. For example, non-overlapping in the first two
    columns::

    28926   31595   2663    1       2670    2663    99.70   139480  2663    1.91
    100.00  contig_26068    AC229726.11_17  contained (0)
    31816   35252   3438    1       3437    3438    99.83   139480  3438    2.46
    100.00  contig_26068    AC229726.11_33  contained (0)
    43009   46210   3205    1       3202    3205    99.78   139480  3205    2.30
    100.00  contig_26068    AC229726.11_30  contained (0)

    You can see that `contig_26068` can serve as linkage for the contigs in BAC
    AC229726 various contigs. Therefore an AGP can be created.
    """
    p = OptionParser(agp.__doc__)

    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())

    coordsfile, = args
    fp = open(coordsfile)
    
    coords = []
    incoming = {}
    outgoing = {}
    for row in fp:
        try:
            c = CoordsLine(row)
        except AssertionError:
            continue

        ov = c.overlap
        if ov == 0: continue  # none
        forward, backward = False, False
        if ov == 1: # a ~ b
            forward = True
        elif ov == 2: # b ~ a
            backward = True
        else: # a in b, b in a
            #forward = backward = True
            pass

        ref, query, score = c.ref, c.query, c.score
        if forward and (query not in incoming or incoming[query][1] < score):
            incoming[query] = (ref, score)
        if backward and (query not in outgoing or outgoing[query][1] < score):
            outgoing[query] = (ref, score)

    from jcvi.algorithms.graph import nx, weakly_connected_components, \
            topological_sort

    g = nx.DiGraph()
    for query, (ref, score) in incoming.items():
        g.add_edge(ref, query, score=score)
    for query, (ref, score) in outgoing.items():
        g.add_edge(query, ref, score=score)

    components = weakly_connected_components(g)
    for c in components:
        sub = g.subgraph(c)
        print topological_sort(sub)

    return


def print_stats(qrycovered, refcovered, id_pct):
    print >>sys.stderr, "Reference coverage: %d bp" % refcovered
    print >>sys.stderr, "Query coverage: %d bp" % qrycovered
    print >>sys.stderr, "ID%%: %.1f%%" % id_pct


def summary(args):
    """
    %prog summary coordsfile 
    
    provide summary on id% and cov%, for both query and reference
    """
    p = OptionParser(summary.__doc__)
    p.add_option("-s", dest="single", default=False, action="store_true",
            help="provide stats per reference seq")

    opts, args = p.parse_args(args)

    if len(args) != 1:
        sys.exit(p.print_help())

    coordsfile, = args
    qrycovered, refcovered, id_pct = get_stats(coordsfile)

    print_stats(qrycovered, refcovered, id_pct)


def filter(args):
    """
    %prog filter test.coords > new.coords

    produce a new coords file and filter based on id% or cov%
    """
    p = OptionParser(filter.__doc__)
    p.add_option("--pctid", dest="pctid", default=0., type="float",
            help="pctid cutoff [default: %default]")
    p.add_option("--hitlen", dest="hitlen", default=0., type="float",
            help="pctid cutoff [default: %default]")
    p.add_option("--overlap", dest="overlap", default=False,
            action="store_true",
            help="print overlap status (e.g. terminal, contained)")

    opts, args = p.parse_args(args)
    if len(args) != 1:
        sys.exit(p.print_help())

    id_cutoff = opts.pctid
    hitlen = opts.hitlen
    assert 0 <= id_cutoff <= 100, "id% needs to be between [0, 100]"

    fp = open(args[0])
    for row in fp:
        try:
            c = CoordsLine(row)
        except AssertionError:
            continue

        if c.identity < id_cutoff: continue
        if c.len2 < hitlen: continue
        if opts.overlap and not c.overlap: continue

        outrow = row.rstrip()
        if opts.overlap:
            ov = Overlap_types[c.overlap]
            outrow += "\t" + ov
        print outrow


def bed(args):
    """
    %prog bed coordsfile

    will produce a bed list of mapped position and orientation (needs to 
    be beyond quality cutoff, say 50) in bed format
    """
    p = OptionParser(bed.__doc__)
    p.add_option("--cutoff", dest="cutoff", default=0, type="float",
            help="get all the alignments with quality above threshold " +\
                 "[default: %default]")

    opts, args = p.parse_args(args)
    if len(args) != 1:
        sys.exit(p.print_help())

    coordsfile, = args
    quality_cutoff = opts.cutoff

    coords = Coords(coordsfile)

    for c in coords:
        if c.quality < quality_cutoff: continue
        print c.bedline


if __name__ == '__main__':
    main()
